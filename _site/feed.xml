<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hoang Duong blog</title>
    <description>Learning Machine Learning</description>
    <link>http://hduongtrong.github.io/</link>
    <atom:link href="http://hduongtrong.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 23 Nov 2015 22:16:42 -0800</pubDate>
    <lastBuildDate>Mon, 23 Nov 2015 22:16:42 -0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>Gradient Descent and Variants - Convergence Rate Summary</title>
        <description>&lt;h4 id=&quot;credits&quot;&gt;Credits&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Ben Retch - Berkeley EE227C Convex Optimization Spring 2015&lt;/li&gt;
&lt;li&gt;Moritz Hardt - &lt;a href=&quot;http://mrtzh.github.io/2013/09/07/the-zen-of-gradient-descent.html&quot;&gt;The Zen of Gradient Descent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Yu. Nesterov - &lt;a href=&quot;http://www.optimization-online.org/DB_FILE/2010/01/2527.pdf&quot;&gt;Efficiency of coordinate descent methods on huge-scale optimization problems&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Peter Richtarik, Martin Takac - &lt;a href=&quot;http://arxiv.org/abs/1107.2848&quot;&gt;Iteration Complexity of Randomized Block-Coordinate Descent Methods for Minimizing a Composite Function&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;goals&quot;&gt;Goals&lt;/h4&gt;

&lt;p&gt;Summary the convergence rate of various gradient descent variants.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Gradient Descent&lt;/li&gt;
&lt;li&gt;Gradient Descent with Momentum&lt;/li&gt;
&lt;li&gt;Stochastic Gradient Descent&lt;/li&gt;
&lt;li&gt;Coordinate Gradient Descent&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;with a focus on the last one.&lt;/p&gt;

&lt;h2 id=&quot;1-gradient-descent&quot;&gt;&lt;strong&gt;1. Gradient Descent&lt;/strong&gt;&lt;/h2&gt;

&lt;h4 id=&quot;1-1-defining-algorithm&quot;&gt;1.1. Defining Algorithm&lt;/h4&gt;

&lt;div class=&quot;imgcap&quot;&gt;
&lt;div&gt;
&lt;img src=&quot;/assets/gradient_descent/gradient_descent.gif&quot;&gt;
&lt;/div&gt;

&lt;div class=&quot;thecap&quot;&gt;Gradient Descent in 2D. Images Credit: http://vis.supstat.com/2013/03/gradient-descent-algorithm-with-r/ &lt;/div&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;The goal here is to minimize a convex function \( f: \mathbb{R} ^ n \rightarrow \mathbb{R} \) without constraint. &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt; [&lt;strong&gt;&lt;em&gt;Convex function&lt;/em&gt;&lt;/strong&gt;] A function \( f : \mathbb{R} ^ n \rightarrow \mathbb{R} \) is convex if its domain of \( f \) is a convex set, and \( \forall x, y \in \rm{dom}(f)\), we have 
$$f(\theta x + (1 - \theta) y) \le \theta f(x) + (1 - \theta) f(y)$$&lt;/p&gt;

&lt;p&gt;Graphically, it means if we connect two points in the graph of the function to create a linear line, that linear line lies above the function (for those points in between). We often work with a nicer definition of convex function, when it is differentiable, as in &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Theorem&lt;/strong&gt; [&lt;strong&gt;&lt;em&gt;First Order Condition&lt;/em&gt;&lt;/strong&gt;] Suppose \( f \) is differentiable. Then \( f \) is convex iff its domain is convex and 
$$ f(y) \ge f(x) + \nabla f(x) ^ T (y - x) , \forall x, y$$&lt;/p&gt;

&lt;p&gt;Graphically, it means the tangent line lies below the function at any point. Finally, we state the second-order condition for completeness.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Theorem&lt;/strong&gt; [&lt;strong&gt;&lt;em&gt;Second Order Condition&lt;/em&gt;&lt;/strong&gt;] Assume that \( f \) is twice differentiable, that is, its Hessian exists at each point in the domain of f, which is open. Then \( f \) is convex iff its Hessian is positive semidefinite. &lt;/p&gt;

&lt;p&gt;Working with general convex function turns out to be very hard, we instead need the following condition&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt; [&lt;strong&gt;&lt;em&gt;L-Lipschitz Gradient&lt;/em&gt;&lt;/strong&gt;] \( f \) is said to has L-Lipschitz gradient iff 
$$ \left | \nabla f(x) - \nabla f(y) \right | \le L || x - y || $$ 
$$ \Leftrightarrow f(y) \le f(x) + \nabla f(x) ^ T (y - x) + \frac{L}{2} || y - x || ^ 2 $$&lt;/p&gt;

&lt;p&gt;Graphically, it means the function is not too convex, it is upperbounded by a quadratic function. Having this condition is necessary in most of the convergence result in gradient descent. Having an additional condition will make life even easier, this condition is stated in &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt; [&lt;strong&gt;&lt;em&gt;m Strongly Convex&lt;/em&gt;&lt;/strong&gt;] \( f \) is strongly convex with constant \( m \) iff 
$$ f(y) \ge f(x) + \nabla f(x) ^ T (y - x) + \frac{m}{2} || y - x || ^ 2 $$&lt;/p&gt;

&lt;p&gt;Basically, it is the opposite of L-Lipschitz gradient, it means the function is not too flat, it is lowerbounded by some quadratic function. We know that at the minimum, a function \( f \) has derivative equal to 0. As such the two L-Lipschitz can be thought of as establishing an upperbound of the change in function values in term of input values. The strongly convex can be thought of as establishing a lowerbound of the change in function values in term of input values. &lt;/p&gt;

&lt;p&gt;We are now ready to define the Gradient Descent algorithm: &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Algorithm&lt;/strong&gt; [&lt;strong&gt;&lt;em&gt;Gradient Descent&lt;/em&gt;&lt;/strong&gt;] 
For a stepsize \( \alpha \) chosen before hand&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Initialize \( x _ 0 \)&lt;/li&gt;
&lt;li&gt;For \( k = 1,2,...\), compute \( x _ {k + 1} = x _ k - \alpha \nabla f(x _ k )\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Basically, it adjust the \( x _ k \) a little bit in the direction where \( f \) decreases the most (the negative gradient direction). In practice, one often choose a variable \( \alpha \) instead of a constant \( \alpha \). &lt;/p&gt;

&lt;h4 id=&quot;1-2-convergence-rate&quot;&gt;1.2. Convergence Rate&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Theorem&lt;/strong&gt; [&lt;strong&gt;&lt;em&gt;Rate for L-Lipschitz and m Strongly Convex&lt;/em&gt;&lt;/strong&gt;]. If \( f \) is L-Lipschitz and strongly convex with constant \( m \), then the Gradient Descent algorithm converges to the right solution, and picking the stepsize \( \alpha = 1 / L \) we have 
$$ f(x _ {k + 1}) - f(x _ \star) \le \left( 1 - \frac{m}{L} \right) (f(x _ k) - f(x _ \star))$$
$$ \Rightarrow f(x _ {k + 1} - f(x _ \star) \le \left( 1 - \frac{m}{L} \right) ^ k (f ( x _ k) - f(x _ \star))$$&lt;/p&gt;

&lt;p&gt;We say the function values converges linearly to the optimal value. Also, since we have the relation between function values and input values, we have \( || x _ k - x _ \star ||\) converges linearly to 0. Here \( x _ \star \) denotes the solution to the optimization problem. For an error threshold of \( \epsilon \), we would need number of iteration in the order of \log \frac{1}{\epsilon} to find a solution within that error threshold. &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Theorem&lt;/strong&gt; [&lt;strong&gt;&lt;em&gt;Rate for L-Lipschizt&lt;/em&gt;&lt;/strong&gt;] If f has L-Lipschitz gradient, then 
$$ f(x _ k) - f(x _ \star) \le \frac{2L}{k + 1} || x _ 0 - x _ \star|| ^ 2 $$&lt;/p&gt;

&lt;p&gt;The convergence rate is not as good, since we are in a more general case. We say the function values converges in log. For an error threshold of \( \epsilon \), we now need in the order of \( \frac{1}{\epsilon} \) iteraions to find a solution within that error threshold. Note that this is much worse than the previous result. &lt;/p&gt;

&lt;p&gt;We quickly mention the (Nesterov) momentum method here, basically, each iteration, instead of updating \( x _ k \) along the direction of gradient, it updates along the weighted average of all the gradient computed so far, with more weight to the recent gradients. I don&amp;#39;t think it&amp;#39;s quite like that but it is the idea, using the previous computed gradients. &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Algorithm&lt;/strong&gt; [&lt;strong&gt;&lt;em&gt;Nesterov Momentum&lt;/em&gt;&lt;/strong&gt;] The update rule for Nesterov method, for constant stepsize \( \alpha \) and momentum rate \( \beta \) is 
$$x _ {k + 1} = x _ k - \alpha \nabla f ( x _ k + \beta (x _ k - x _ { k - 1} ) + $$ 
$$+ \beta ( x _ k - x _ { k - 1})$$&lt;/p&gt;

&lt;p&gt;If we were to be careful with the analysis before, for L-Lipschitz gradient and strongly convex function with parameter \( m \), we have the rate of convergence is \( O \left( \frac{L}{m} \log \frac{1}{\epsilon} \right)\). With the Nesterov method, we get an improvement to \( O \left( \sqrt{\frac{L}{m}} \log \frac{1}{\epsilon} \right)\). Similarly, for L-Lipschitz gradient, the error rate before was \( O \left( \frac{L}{\epsilon} \right)\), now with Nesterov momentum method, we have \( O \left( \sqrt{\frac{L}{\epsilon}}\right)\). 
So Nesteve momentum method gives a bit better rate for very little computational cost. &lt;/p&gt;

&lt;h2 id=&quot;2-coordinate-descent&quot;&gt;&lt;strong&gt;2. Coordinate Descent&lt;/strong&gt;&lt;/h2&gt;

&lt;h4 id=&quot;2-1-defining-algorithm&quot;&gt;2.1. Defining Algorithm&lt;/h4&gt;

&lt;div class=&quot;imgcap&quot;&gt;
&lt;div&gt;
&lt;img src=&quot;/assets/gradient_descent/coordinate_descent.gif&quot;&gt;
&lt;/div&gt;

&lt;div class=&quot;thecap&quot;&gt;Coordinate Descent in 2D. Images Credit: Martin Takac&lt;/div&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;In Machine Learning, we sometimes work with the case where the dimension is too big, or there is too many datapoint. Consider a data matrix \( X \in \mathbb{R} ^ {m \times n}\), if \( m \) is too big, one can do Stochastic (Batch) Gradient Descent, which instead of calculating the gradient on all \( m \) data points, it approximate the gradient with only \( b \) data points, for \( b \) is the batch size (for example \( b = 128\), while \( m \approx 1000000 \)). On the other hand, if \( n\) is big, we can upgrade a few of coordinate per iteration, instead of updating the whole \( n \) dimension. This is Coordinate descent.&lt;/p&gt;

&lt;p&gt;For those problem where calculating coordinate gradient (i.e. partial derivative) is simple, it turns out the the rate for coordinate descent is as good as for typical gradient descent. First let&amp;#39;s define the L-Lipschitz condition coordinatewise&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt; [&lt;strong&gt;&lt;em&gt;Coordinate-wise Lipschitz gradient&lt;/em&gt;&lt;/strong&gt;] \( f \) is L-Lipschitz coordinate-wise with constant \( L _ i\) at coordinate \( i \) iff
$$ \left\lVert \nabla f (x + h _ i) - \nabla f (x) \right\rVert \le L _ i \left\lVert h _ i \right\rVert$$
for \( h_i \) is zero everywhere except at coordinate \( i \). &lt;/p&gt;

&lt;p&gt;We assume our function \( f \) is L-Lipschitz coordinate wise with constant \( L _ i, i = 1,2,...,n \). Then the Randomized Coordinate Descent Method is defined as followed:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Algorithm&lt;/strong&gt; [&lt;strong&gt;&lt;em&gt;Randomized Coordinate Descent&lt;/em&gt;&lt;/strong&gt;] &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pick an initial point \( x _ 0\)&lt;/li&gt;
&lt;li&gt;For \( k = 1,2,... \) 

&lt;ul&gt;
&lt;li&gt;pick coordinate \( i \) randomly with uniform probability&lt;/li&gt;
&lt;li&gt;compute \( x _ {k + 1} = x _ k - \frac{1}{L _ i} \nabla f (x)[i]\).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here we introduce the notation \( \nabla f(x)[i]\) from array notation to say take the \( i ^ {th} \) element of vector \( \nabla f(x) \). A lot of things can be relaxed from this, for example, the probability can be general not uniform. Instead of doing single coordinate-wise, one can do block coordinate-wise. One can also add a regularization term like \( \ell _ 1 \) (Lasso) or \( \ell _ 2\) Ridge. See paper by Peter Richtarik and Martin Takac for details. Once can also work with more general norm (in the L-Lipschitz condition). We just state this simple case for simplicity. &lt;/p&gt;

&lt;h4 id=&quot;2-2-convergence-in-expectation&quot;&gt;2.2. Convergence in Expectation&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Theorem&lt;/strong&gt; [&lt;strong&gt;&lt;em&gt;Rate Coordinate Descent with Lipschitz&lt;/em&gt;&lt;/strong&gt;] If we run the above algorithm for coordinate-wise L-Lipschitz gradient, we have
$$\mathbb{E} _ {k - 1} f(x _ k) - f ^ \star \le \frac{2n}{k + 4}  R ^ 2 (x _ 0),$$
for $$ R(x _ 0) = \max _ x \left[ \max _ { x _ {\star} \in X _ {\star}} \left\lVert x - x _ \star \right\rVert _ 1  \right] : f(x) \le f(x _ 0) $$&lt;/p&gt;

&lt;p&gt;So basically, we have the log-convergence rate in expectation, very similar to Gradient Descent. Analogously, the result for strongly convex (globally, not coordinate-wise) is stated in &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Theorem&lt;/strong&gt; [&lt;strong&gt;&lt;em&gt;Rate Coordinate Descent with Lipschitz and Strongly Convex m&lt;/em&gt;&lt;/strong&gt;] If we run the above algorithm, we have 
$$ \mathbb{E} _ {k - 1} f(x _ k) - f ^ \star \le \left( 1 - \frac{m}{n} \right) ^ k (f(x _ 0) - f ^ \star)$$&lt;/p&gt;

&lt;p&gt;Note that here \( m \) is the strongly convex parameter, not the number of observation as we used it before. For those of you who are curious, this result and the previous theorem are in Nesterov paper (his Theorem 1 and Theorem 2), applying for the case \( \alpha = 0\), which then imply \( S _ \alpha (f) = n\). &lt;/p&gt;

&lt;p&gt;So basically, we get that for Strongly convex and L-Lipschitz gradient, we also get linear convergence rate in the expectation for Coordinate Descent.&lt;/p&gt;

&lt;h4 id=&quot;2-3-high-probability-statement&quot;&gt;2.3. High Probability Statement&lt;/h4&gt;

&lt;p&gt;One might also wonder that maybe it works on average, but we only run it once, what is the probability that the result we get from that one time is good. It turns out that our result is good with high probability, as seen in Peter Richtarik, Martin Takac paper. The idea is to used Markov inequality to convert a statement in expectation to a high probability statement. To summary, for a fix confidence interval \( \rho \in (0,1) \), if we pick 
$$ k \ge O \left( \frac{2n}{\epsilon} \log \frac{f(x _ 0) - f(x _ \star)}{\epsilon \rho} \right), $$ 
we have \( \mathbb{P} [f (x _ k) - f (x _ \star) \le \epsilon ] \ge 1 - \rho \), if the function is coordinate-wise L-Lipschitz gradient. &lt;/p&gt;

&lt;p&gt;If in addition, we have strongly convex, then the number of iteration needed is only 
$$ k \ge O \left ( n \log \left( \frac{f(x _ 0) - f(x _ \star)}{\rho \epsilon} \right)\right).$$&lt;/p&gt;

&lt;p&gt;Staring at these high-probability result, we see that the number of iteration needed is almost identical to the case of vanilla Gradient Descent. We have \( 1 / \epsilon \) rate for Lipschitz gradient, and \( \log (1 / \epsilon)\) if we have strongly convexity in addition. The rate is however \( n \) times slower, because each iteration of Coordinate Descent is approximately \( n \) times faster than Gradient Descent (calculating gradient along one coordinate vs calculating gradient along all coordinate). The minor difference is the cost of \( \log {1}{\epsilon} \) for the case of only L-Lipschitz can in fact be removed. It is only there when we are optimizing an objective with regularization term (L1 or L2 regularization).&lt;/p&gt;

&lt;p&gt;Finally, on a note about momentum for Coordinate Descent, it seems Nesterov recommends not using it, because of the computation complexity for getting the momentum.  &lt;/p&gt;

&lt;h2 id=&quot;3-stochastic-gradient-descent&quot;&gt;&lt;strong&gt;3. Stochastic Gradient Descent&lt;/strong&gt;&lt;/h2&gt;

&lt;div class=&quot;imgcap&quot;&gt;
&lt;div&gt;
&lt;img src=&quot;/assets/gradient_descent/all.gif&quot;&gt;
&lt;/div&gt;

&lt;div class=&quot;thecap&quot;&gt;Popular optimization algorithms. Images Credit: Daniel Nouri&lt;/div&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;It is quite surprised for me that analyzing Stochastic Gradient Descent is much harder than Coordinate Descent. The two algorithms sounds very similar, it is just the former one is vertical, while the later one is horizontal. SGD in fact works very well in practice, it is just proving convergence result is harder. For strongly convex, it seems we only get log convergence rate (as compared to linear in Gradient Descent), as seen in &lt;a href=&quot;http://research.microsoft.com/en-us/um/cambridge/events/mls2013/downloads/stochastic_gradient.pdf&quot;&gt;SGD for Machine Learning&lt;/a&gt;. For non-strongly convex, we get half the rate. Why??? What is the rate of SGD? To be discovered and written. If you have some ideas please comment. &lt;/p&gt;
</description>
        <pubDate>Mon, 23 Nov 2015 06:44:27 -0800</pubDate>
        <link>http://hduongtrong.github.io/2015/11/23/coordinate-descent/</link>
        <guid isPermaLink="true">http://hduongtrong.github.io/2015/11/23/coordinate-descent/</guid>
        
        
      </item>
    
      <item>
        <title>Word Representation - Word2Vec</title>
        <description>&lt;h2 id=&quot;credits&quot;&gt;Credits&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Original authors: &lt;a href=&quot;http://arxiv.org/abs/1301.3781&quot;&gt;Efficient Estimation of Word Representations in Vector Space&lt;/a&gt;. Tomas Mikolov, Kai Chen, Greg Corrado, Jeffrey Dean.&lt;/li&gt;
&lt;li&gt;Code Website: &lt;a href=&quot;https://code.google.com/p/word2vec/&quot;&gt;Word2Vec&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Explained Paper: &lt;a href=&quot;http://u.cs.biu.ac.il/%7Enlp/wp-content/uploads/Neural-Word-Embeddings-as-Implicit-Matrix-Factorization-NIPS-2014.pdf&quot;&gt;Neural Word Embedding as Implicit Matrix Factorization&lt;/a&gt;. Omer Levy, Yoav Goldberg&lt;/li&gt;
&lt;li&gt;Explained Paper Short Version: &lt;a href=&quot;http://arxiv.org/abs/1402.3722&quot;&gt;Word2vec Explained&lt;/a&gt;. Yoav Goldberg, Omer Levy&lt;/li&gt;
&lt;li&gt;Code easier to understand: &lt;a href=&quot;https://github.com/fchollet/keras/blob/master/examples/skipgram_word_embeddings.py&quot;&gt;Keras Word2vec&lt;/a&gt;. Francois Chollet. &lt;/li&gt;
&lt;li&gt;TensorFlow code: &lt;a href=&quot;http://tensorflow.org/tutorials/word2vec/index.md&quot;&gt;TensorFlow word2vec&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If your time is in short supply, just read the Explained Paper Short Version. &lt;/p&gt;

&lt;h2 id=&quot;goals&quot;&gt;Goals&lt;/h2&gt;

&lt;p&gt;English language has in the order of 100,000 words. If we are working on an NLP problem, one can represent each word as a one-hot vector of dimension 100,000. This is a sparse and high dimension input. Our goal is to map this into dense low dimensional input of around 300 dimension, \( v _w\). Then we can feed this to some other model like LSTM for some NLP tasks. Hopefully, our new representation respects some semantic rules like &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Words with similar meaning should be close to each other&lt;/li&gt;
&lt;li&gt;The direction from &amp;quot;do&amp;quot; to &amp;quot;doing&amp;quot; should be similar to &amp;quot;go&amp;quot; to &amp;quot;going&amp;quot;&lt;/li&gt;
&lt;li&gt;Doing addition: King - male + female ~ queen&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It is surprising that word2vec can give us this, without any label on the meaning of words. All it needs is words cooccurance. It is also surpsisingly simple, nothing more complicated than logistic regression.&lt;/p&gt;

&lt;h2 id=&quot;ideas-of-word2vec&quot;&gt;Ideas of Word2vec&lt;/h2&gt;

&lt;p&gt;Given a sentence: &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You used to call me on my cell phone. &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;and a window k (consider k = 1 for simplicity), we define the context of a word as its 2k neighbor words. Word2vec defines the positive dataset \( \mathcal{D} \) of &lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;word&lt;/th&gt;
&lt;th&gt;context&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;you&lt;/td&gt;
&lt;td&gt;used&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;used&lt;/td&gt;
&lt;td&gt;you&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;used&lt;/td&gt;
&lt;td&gt;to&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;to&lt;/td&gt;
&lt;td&gt;used&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;to&lt;/td&gt;
&lt;td&gt;call&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;Each of these pair did appear in the dataset, so we associate them with a label 1. We now define the negative word pairs dataset \( \mathcal{D&amp;#39;} \) &lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;word&lt;/th&gt;
&lt;th&gt;non_context&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;you&lt;/td&gt;
&lt;td&gt;random_word1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;used&lt;/td&gt;
&lt;td&gt;random_word2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;to&lt;/td&gt;
&lt;td&gt;random_word3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;call&lt;/td&gt;
&lt;td&gt;random_word4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;and label these pair as 0 (Note that when we pick one random word from the vocabulary, there is some tiny chance that the picked word is actually a valid context, but it is very small that we consider it 0).  &lt;/p&gt;

&lt;p&gt;We then use the logistic loss to train a vector representation for each word such as it maximize
$$ \arg \max _{\theta} \prod _{(w,c) \in \mathcal{D}}  p(D _{w,c} = 1 \mid w,c,\theta) 
                       \prod _{(w,c) \in \mathcal{D&amp;#39;}} p(D _{w,c} = 0 \mid w,c,\theta).$$
So we basically maximize the probability of seeing those word pairs in \( \mathcal{D}\), and not seeing those word pairs in \( \mathcal{D&amp;#39;}\). Taking log, we can rewrite the optimization as 
$$ \arg \max _{\theta} \sum _{(w,c) \in \mathcal{D }} \log \sigma(  v _c \cdot v _w) + 
                       \sum _{(w,c) \in \mathcal{D&amp;#39;}} \log \sigma(- v _c \cdot v _w),$$
for \( \sigma(x) = \frac{1}{1 + e ^ {-x}} \)&lt;/p&gt;

&lt;p&gt;Now to be clear, all of the \( v _w\) are our vector representation of word, together, they form a matrix of size (vocabulary size by projection size), e.g. (100,000 by 300). All of the \( v _c \) are our vector representation of context, together, they form a matrix of similar size if we have one negative sample per positive sample. In practice this later matrix is often discarded. We basically optimize with respect to those two matrix, such that the product \( v _c \cdot v _w\) is big for those [word, context] we see in our dataset, and small for those [word, context] we do not see in our dataset. &lt;/p&gt;

&lt;h2 id=&quot;enhancement&quot;&gt;Enhancement&lt;/h2&gt;

&lt;p&gt;The final method used is a bit more complicated, with tricks that make it work better, for example&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Instead of sampling one negative context per [word, context] pair uniformly, it samples \(m\) context words with probability distribution proportional to how often each context word is in the dataset.&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Instead of using a fix \( k\) window around each word, the window is uniformly distributed from \( 1,2, ..., K \)&lt;/li&gt;
&lt;li&gt;Treat all rare words as an &amp;quot;UNK&amp;quot; token, and downsampling most common words. &lt;/li&gt;
&lt;li&gt;The method we mention so far is called the Skip-Gram Negative Sampling, the original paper also mentions the Continuous Bag of Words, where it models the probability of word given context.  The authors claim that the skip-gram negative sampling works better for bigger dataset (see more in the TensorFlow example). &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;extra&quot;&gt;Extra&lt;/h2&gt;

&lt;p&gt;This word representation, finding the two vector (matrix) representation \( V _w\) and \( V _c\) can be thought of as factorizing an implicit matrix \( M = V _w \cdot V _c ^ T \), where each element of \( M, M _{ij}\) reflect the strength of association between word \( i \) and context \( j\). More specifically, it is found that 
$$ M _{ij} = v _w \cdot v _c = PMI(w _i, c _j) - \log k$$, 
for PMI is the pointwise mutual information, defined as 
$$PMI(w _i, c _j) = \log \left( \frac { N(w,c) |\mathcal{D}|}{ N(w) N(c) } \right)$$, 
for \( N(w)\) counts the number of occurance of \(w  \) in \( \mathcal{D}\)&lt;/p&gt;

&lt;h2 id=&quot;testing-out&quot;&gt;Testing out&lt;/h2&gt;

&lt;p&gt;The official website of word2vec has a very fast code in C++, where one can test things out pretty easily. Head over there, training the model should take five minutes. It even has the option of download pre-trained models. Here I&amp;#39;m using there pre-trained model on Google News words, and find similar words to a word (think of this like a Thesaurus)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Word: eminem  Position in vocabulary: 566691&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;        Word       Cosine distance
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;       jay z      0.732697
   rick_ross      0.731509
       kanye      0.715282
        shyt      0.705407
 chris brown      0.697447
       i luv      0.694622
   lady gaga      0.690142
  john mayer      0.686606
        ozzy      0.678592
  soulja boy      0.671136
     rihanna      0.670854
        juss      0.670568
   lil wayne      0.669848
     beyonce      0.667990
       cuz u      0.664925
      mariah      0.664813
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
</description>
        <pubDate>Fri, 20 Nov 2015 07:28:27 -0800</pubDate>
        <link>http://hduongtrong.github.io/2015/11/20/word2vec/</link>
        <guid isPermaLink="true">http://hduongtrong.github.io/2015/11/20/word2vec/</guid>
        
        
      </item>
    
      <item>
        <title>Deep Reinforcement Learning</title>
        <description>&lt;p&gt;(INCOMPLETE)
Deep Reinforcement Learning is an exciting new field that encompasses many
different fields: computer science, optimal control, statistics, machine
learning, and so on. Its application are numerous.&lt;/p&gt;

&lt;h2 id=&quot;policy-gradient&quot;&gt;Policy Gradient&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt; A Markov Decision Process contains&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;\( \pi : \mathcal{S} \rightarrow \Delta(\mathcal(A)) \), the stochastic policy. &lt;/li&gt;
&lt;li&gt;\( \eta(\pi) = \mathbb{E} \left[ R_0 + \gamma R_1 + \gamma&lt;sup&gt;2&lt;/sup&gt; R_2 +&lt;br&gt;
... \right] \)&lt;/li&gt;
&lt;li&gt;\( p: \mathcal{S} \times \mathcal{A} \times \mathcal{S} \rightarrow \mathbb{R} \), the state transition probability&lt;/li&gt;
&lt;li&gt;\( \mu : \mathcal{S} \rightarrow \mathbb{R} \), the probability distribution over the initial state, \( s_0 \)&lt;/li&gt;
&lt;li&gt;\( \theta \in \mathbb{R}&lt;sup&gt;n&lt;/sup&gt; \), a vector of parameter that parameterizes the stochastic policy \(\pi\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A policy gradient algorithm then calculate \( \nabla_ {\theta} \eta (\theta) \), and make proceed as a standard gradient ascent algorithm. We approximate the gradient using Monte Carlo estimation, since we don&amp;#39;t have access to the underlying probability distribution. &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Theorem&lt;/strong&gt; Monte Carlo estimation. Let \( X : \Omega \rightarrow \mathbb{R} ^ n \) be a random variable with probability distribution \(q\), and \(f : \mathbb {R}&lt;sup&gt;n&lt;/sup&gt; \rightarrow \mathbb{R} \). Then 
    $$ \frac{\partial}{\partial \theta } \mathbb {E} \left[ f(X) \right] = 
        \mathbb{E} \left[ f(X) \frac{\partial}{\partial \theta } 
        \log q(X;\theta) \right]$$&lt;/p&gt;

&lt;p&gt;Armed with this theorem, we can use a sample average to estimate the expectation. &lt;/p&gt;
</description>
        <pubDate>Mon, 19 Oct 2015 18:28:27 -0700</pubDate>
        <link>http://hduongtrong.github.io/2015/10/19/deep-reinforcement-learning/</link>
        <guid isPermaLink="true">http://hduongtrong.github.io/2015/10/19/deep-reinforcement-learning/</guid>
        
        
      </item>
    
      <item>
        <title>How to make a blog like this</title>
        <description>&lt;h2 id=&quot;motivation&quot;&gt;Motivation&lt;/h2&gt;

&lt;p&gt;I have been seeing beautiful blog posts coupled with great contents such as &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.mrtz.org/2013/09/07/the-zen-of-gradient-descent.html&quot;&gt;The Zen of Gradient Descent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://karpathy.github.io/2015/05/21/rnn-effectiveness/&quot;&gt;The Unreasonable Effectiveness of Recurrent Neural Networks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://colah.github.io/posts/2015-08-Understanding-LSTMs/&quot;&gt;Understanding LSTM Networks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;My definition of being &amp;quot;beautiful&amp;quot; is just text and no distraction, look
good both on mobile and on desktop, and display Latex. My definition of &amp;quot;great
content&amp;quot; often involve machine learning, optimization, and related topics. &lt;/p&gt;

&lt;h2 id=&quot;setting-up&quot;&gt;Setting up&lt;/h2&gt;

&lt;p&gt;So without being further ado, let&amp;#39;s start with how to make a blog like those
three mentioned above blog. You will need a couple components:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://jekyllrb.com&quot;&gt;Jekyll&lt;/a&gt;: Pretty easy to install on Mac, just follow the
link&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pages.gith%E2%80%A6&quot;&gt;Github Pages&lt;/a&gt;: Also pretty easy to setup. Create a
github account if you haven&amp;#39;t got one, then follow the link.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://help.github.com/articles/markdown-basics/&quot;&gt;Markdown&lt;/a&gt;: Used to generate html file from simpler looking file (no need to install this)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.mathjax.org&quot;&gt;Mathjax&lt;/a&gt;: For typing Latex. No need to install this either&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After spending some good hours and failing at setting up the various 
requirements, here is the trick I found: just clone the blog of the people
above. In particular, I clone Karpathy blog into mine. Many thanks to Andre
Karpathy for this, and my apology if my blog accidentally contains some stuffs
from yours. Ok now open &lt;strong&gt;Terminal&lt;/strong&gt; in Mac:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;mkdir MyBlog
&lt;span class=&quot;c&quot;&gt;# Downloading sample github page from Andre Karpathy&lt;/span&gt;
git clone https://github.com/karpathy/karpathy.github.io.git
&lt;span class=&quot;c&quot;&gt;# Downloading your own github page blog. Replacing username with your github&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# user name&lt;/span&gt;
git clone https://github.com/username/username.github.io.git
cp ./karpathy.github.io/* ./username.github.io/
&lt;span class=&quot;c&quot;&gt;# Removing stuff associated with the original owner&lt;/span&gt;
rm nntutorial.md
rm _posts/* &lt;span class=&quot;c&quot;&gt;# Hist posts&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You will need to change a few more information. Open &lt;code&gt;_config.yaml&lt;/code&gt;_ and change
all the detail in there to your username. Change things in &lt;code&gt;about.md&lt;/code&gt; as well. 
Also in &lt;code&gt;_layouts/post.html&lt;/code&gt; and
&lt;code&gt;_layouts/page.html&lt;/code&gt;, there is a part with &amp;quot;karpathy&amp;quot;, change that to your
username. Basically, search for all text with the original owner&amp;#39;s name and
replace them with your name. You might also want to delete everything in i
&lt;code&gt;assets&lt;/code&gt;, as those are the picture that the original owner uses.  &lt;/p&gt;

&lt;p&gt;And voila, you are done.&lt;/p&gt;

&lt;h2 id=&quot;hello-world&quot;&gt;Hello World&lt;/h2&gt;

&lt;p&gt;To create your first blog post, again copy over a sample post say from&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;cp ./karpathy.github.io/_posts/2015-05-21-rnn-effectiveness.markdown
   ./username.github.io/_posts/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And you can start changing things in there. Then do this &lt;code&gt;jekyll serve&lt;/code&gt; inside
your &lt;code&gt;username.github.io&lt;/code&gt; folder. You should see something like this if
successful &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Configuration file: /Users/hd/Documents/Blog/hduongtrong.github.io/_config.yml
            Source: /Users/hd/Documents/Blog/hduongtrong.github.io
       Destination: /Users/hd/Documents/Blog/hduongtrong.github.io/_site
      Generating... 
     Build Warning: Layout &amp;#39;none&amp;#39; requested in feed.xml does not exist.
                    done.
 Auto-regeneration: enabled for &amp;#39;/Users/hd/Documents/Blog/hduongtrong.github.io&amp;#39;
Configuration file: /Users/hd/Documents/Blog/hduongtrong.github.io/_config.yml
    Server address: http://127.0.0.1:4000/
  Server running... press ctrl-c to stop.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Open your web browser, and go to &lt;code&gt;http://127.0.0.1:4000/&lt;/code&gt;, you will see your
post there. &lt;/p&gt;

&lt;p&gt;Now to push this online, just &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;username.github.io/
git add .
git commit -m &lt;span class=&quot;s2&quot;&gt;&amp;quot;First blog&amp;quot;&lt;/span&gt;
git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And go to &lt;code&gt;username.github.io&lt;/code&gt;.&lt;/p&gt;
</description>
        <pubDate>Mon, 19 Oct 2015 09:46:27 -0700</pubDate>
        <link>http://hduongtrong.github.io/2015/10/19/how-setting-up-blog/</link>
        <guid isPermaLink="true">http://hduongtrong.github.io/2015/10/19/how-setting-up-blog/</guid>
        
        
      </item>
    
  </channel>
</rss>
